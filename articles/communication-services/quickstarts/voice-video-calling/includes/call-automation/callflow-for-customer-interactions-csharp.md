---
title: include file
description: Provides a quickstart on how to use Call Automation C# SDK to build call flow for customer interactions.
services: azure-communication-services
author: ashwinder

ms.service: azure-communication-services
ms.subservice: azure-communication-services
ms.date: 09/06/2022
ms.topic: include
ms.custom: include file
ms.author: askaur
---

## Prerequisites

- An Azure account with an active subscription.
- A deployed Communication Service resource.
- [Acquire a PSTN phone number from the Communication Service resource](../../../telephony/get-phone-number.md?pivots=programming-language-csharp).
- The latest [.NET library](https://dotnet.microsoft.com/download/dotnet-core) for your operating system.
- A [web service application](https://dotnet.microsoft.com/download/dotnet-core) to handle web hook callback events.
- Optional: [NGROK application](https://ngrok.com/) to proxy HTTP/S requests to a local development machine.
- The [ARMClient application](https://github.com/projectkudu/ARMClient), used to configure the Event Grid subscription.
- Obtain the NuGet package from the [Azure SDK Dev Feed](https://github.com/Azure/azure-sdk-for-net/blob/main/CONTRIBUTING.md#nuget-package-dev-feed)
- [An Event Grid subscription for Incoming Call](../../../../how-tos/call-automation-sdk/subscribe-to-incoming-call.md)

## Create a new C# application

In the console window of your operating system, use the `dotnet` command to create a new web application.

```console
    dotnet new web -n MyApplication
```

## Install the NuGet package

During the preview phase, the NuGet package can be obtained by configuring your package manager to use the Azure SDK Dev Feed from [here](https://github.com/Azure/azure-sdk-for-net/blob/main/CONTRIBUTING.md#nuget-package-dev-feed)

## Obtain your connection string

From the Azure portal, locate your Communication Service resource and click on the Keys section to obtain your connection string.

:::image type="content" source="./../../media/call-automation/Key.png" alt-text="Screenshot of Communication Services resource page on portal to access keys":::

## Configure Program.cs to answer the call

Using the minimal API feature in .NET 6, we can easily add an HTTP POST map and answer the call. A callback URI is required so the service knows how to contact your web server for subsequent calls state events such as `CallConnected` and `PlayCompleted`.  

NOTE: The code sample also illustrates how you can control the callback URI by setting your own context/ID when you answer the call. All events generated by the call will be sent to the specific route you provide when answering an inbound call and the same applies to when you place an outbound call.
``` csharp
using Azure.Communication;
using Azure.Communication.CallAutomation;
using Azure.Messaging;
using Azure.Messaging.EventGrid;
using Azure.Messaging.EventGrid.SystemEvents;
using Microsoft.AspNetCore.Mvc;
using System.Text.Json.Nodes;

var builder = WebApplication.CreateBuilder(args);

var client = new CallAutomationClient(builder.Configuration["ACS:ConnectionString"]);
var callbackUriBase = "<YOUR_NGROK_FQDN>"; // i.e. https://someguid.ngrok.io

var app = builder.Build();
app.MapPost("/api/incomingCall", async (
    [FromBody] EventGridEvent[] eventGridEvents) =>
{
    foreach (var eventGridEvent in eventGridEvents)
    {
        // Handle system events
        if (eventGridEvent.TryGetSystemEventData(out object eventData))
        {
            // Handle the subscription validation event
            if (eventData is SubscriptionValidationEventData subscriptionValidationEventData)
            {
                var responseData = new SubscriptionValidationResponse
                {
                    ValidationResponse = subscriptionValidationEventData.ValidationCode
                };
                return Results.Ok(responseData);
            }
        }
        var jsonObject = JsonNode.Parse(eventGridEvent.Data).AsObject();
        var incomingCallContext = (string)jsonObject["incomingCallContext"];
        var callbackUri = new Uri(callbackUriBase + $"/api/calls/{Guid.NewGuid()}");
        AnswerCallResult answerCallResult = await client.AnswerCallAsync(incomingCallContext, callbackUri);
    }
    return Results.Ok();
});

app.MapPost("/api/calls/{contextId}", async (
    [FromBody] CloudEvent[] cloudEvents,
    [FromRoute] string contextId) =>
{
    foreach (var cloudEvent in cloudEvents)
    {
        CallAutomationEventBase @event = CallAutomationEventParser.Parse(cloudEvent);
        if (@event is CallConnected)
        {
            // play audio then recognize 3-digit DTMF input with pound (#) stop tone
            var recognizeOptions =
                new CallMediaRecognizeDtmfOptions(new PhoneNumberIdentifier("<Target-Participant-Phone-Number>"), 3)
                {
                    InterruptPrompt = true,
                    InterToneTimeout = TimeSpan.FromSeconds(10),
                    InitialSilenceTimeout = TimeSpan.FromSeconds(5),
                    Prompt = new FileSource(new Uri("<INSERT_AUDIO_FILE_URI>")),
                    StopTones = new[] { DtmfTone.Pound },
                    OperationContext = "MainMenu"
                };
            await client.GetCallConnection(@event.CallConnectionId)
                .GetCallMedia()
                .StartRecognizingAsync(recognizeOptions);
        }
        if (@event is RecognizeCompleted { OperationContext: "MainMenu" })
        {
            // this RecognizeCompleted correlates to the previous action as per the OperationContext value
            await client.GetCallConnection(@event.CallConnectionId)
                .AddParticipantsAsync(new AddParticipantsOptions(
                    new List<CommunicationIdentifier>()
                    {
                        new CommunicationUserIdentifier("<ACS_ID>")
                    }));
        }
    }
    return Results.Ok();
}).Produces(StatusCodes.Status200OK);

app.Run();
```
